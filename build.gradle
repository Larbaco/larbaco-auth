plugins {
    id 'java-library'
    id 'maven-publish'
    id 'net.neoforged.moddev' version '1.0.21'
    id "com.matthewprenger.cursegradle" version "1.4.0"
}

tasks.named('wrapper', Wrapper).configure {
    distributionType = Wrapper.DistributionType.BIN
}


def getVersionFromChangelog() {
    def changelog = file("CHANGELOG.md")
    if (!changelog.exists()) throw new GradleException("CHANGELOG.md not found")

    def latestVersion = null
    changelog.eachLine { line ->
        // Match lines like "## Version X.Y.Z"
        if (line.startsWith("## Version ")) {
            def versionMatch = (line =~ /## Version\s+([\w\.\-]+)/)
            if (versionMatch.find()) {
                latestVersion = versionMatch.group(1).trim()
                return // Stop after first match (latest version)
            }
        }
    }
    if (!latestVersion) throw new GradleException("No valid version found in CHANGELOG.md")
    return latestVersion
}


version = getVersionFromChangelog()
group = mod_group_id

repositories {
    mavenLocal()
    mavenCentral()
}

base {
    archivesName = mod_id
}

java.toolchain.languageVersion = JavaLanguageVersion.of(21)

tasks.named('jarJar', net.neoforged.moddevgradle.tasks.JarJar) {
    setEnabled(true)
}

neoForge {
    version = project.neo_version
    parchment {
        mappingsVersion = project.parchment_mappings_version
        minecraftVersion = project.parchment_minecraft_version
    }

    runs {
        client {
            client()

            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        server {
            server()
            programArgument '--nogui'
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        gameTestServer {
            type = "gameTestServer"
            systemProperty 'neoforge.enabledGameTestNamespaces', project.mod_id
        }

        data {
            data()

            programArguments.addAll '--mod', project.mod_id, '--all', '--output', file('src/generated/resources/').getAbsolutePath(), '--existing', file('src/main/resources/').getAbsolutePath()
        }

        configureEach {
            systemProperty 'forge.logging.markers', 'REGISTRIES'

            logLevel = org.slf4j.event.Level.DEBUG
        }
    }

    mods {
        "${mod_id}" {
            sourceSet(sourceSets.main)
        }
    }
}

sourceSets.main.resources { srcDir 'src/generated/resources' }

configurations {
    runtimeClasspath.extendsFrom localRuntime
}

dependencies {
    implementation 'org.mindrot:jbcrypt:0.4'
    implementation 'com.google.code.gson:gson:2.10.1'
    jarJar(group: 'org.mindrot', name: 'jbcrypt', version: '0.4') {
        transitive = false
    }
}

var generateModMetadata = tasks.register("generateModMetadata", ProcessResources) {
    var replaceProperties = [
            minecraft_version      : minecraft_version,
            minecraft_version_range: minecraft_version_range,
            neo_version            : neo_version,
            neo_version_range      : neo_version_range,
            loader_version_range   : loader_version_range,
            mod_id                 : mod_id,
            mod_name               : mod_name,
            mod_license            : mod_license,
            mod_version            : mod_version,
            mod_authors            : mod_authors,
            mod_description        : mod_description
    ]
    inputs.properties replaceProperties
    expand replaceProperties
    from "src/main/templates"
    into "build/generated/sources/modMetadata"
}
sourceSets.main.resources.srcDir generateModMetadata
neoForge.ideSyncTask generateModMetadata

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
        }
    }
    repositories {
        maven {
            url = "file://${System.properties['user.home']}/curseforge-test/repo"
        }
    }
}

// ===== CURSEFORGE PUBLISHING ===== //
curseforge {
    apiKey = project.findProperty("curseforge_key") ?: System.getenv("CURSEFORGE_KEY")

    project {
        id = "1242580"
        changelogType = "markdown"
        changelog = file("CHANGELOG.md")
        releaseType = "alpha"
        addGameVersion minecraft_version
        relations {

        }
    }

    options {
        forgeGradleIntegration = false
        debug = false // Enables dry-run mode
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
}

idea {
    module {
        downloadSources = true
        downloadJavadoc = true
    }
}

def updateLicenseHeaders = tasks.register('updateLicenses') {
    group = 'help'
    description = 'Adds license headers to all source files with verbose output'

    def headerFile = file('LICENSE_HEADER.txt')
    def sourceDir = file('src/')
    def header = headerFile.text.trim()
    def stats = [updated: 0, skipped: 0, ok: 0]

    inputs.file(headerFile)
    inputs.dir(sourceDir)
    outputs.dir(sourceDir)

    doLast {
        logger.lifecycle("\nLicense Header Update Report:")
        logger.lifecycle("=" * 40)

        sourceDir.eachFileRecurse { file ->
            if (file.isFile() && file.name.endsWith('.java')) {
                if (file.text.contains(header)) {
                    logger.info("[OK] ${file.path} (already has license)")
                    stats.ok++
                } else {
                    try {
                        def original = file.text
                        file.text = header + "\n\n" + original
                        logger.lifecycle("[UPDATED] ${file.path}")
                        stats.updated++
                    } catch (Exception e) {
                        logger.error("[FAILED] ${file.path} - ${e.message}")
                    }
                }
            } else if (file.isDirectory()) {
                logger.debug("[DIR] ${file.path} (skipping directory)")
            } else {
                logger.debug("[SKIP] ${file.path} (not a Java file)")
                stats.skipped++
            }
        }

        logger.lifecycle("\nSummary:")
        logger.lifecycle("-" * 40)
        logger.lifecycle("Files updated: ${stats.updated}")
        logger.lifecycle("Files already OK: ${stats.ok}")
        logger.lifecycle("Files skipped: ${stats.skipped}")
        logger.lifecycle("=" * 40 + "\n")
    }
}

